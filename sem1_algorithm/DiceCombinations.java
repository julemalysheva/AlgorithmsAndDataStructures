package sem1_algorithm;
// ниже закомментирован вариант от ChatGPT с комментами, выводом самих комбинаций и их количеством
// здесь переписываю под задачу только с количеством

public class DiceCombinations {

    public static void main(String[] args) {
        int k = 6; // количество кубиков
        int n = 6; // количество граней на каждом кубике
        int combinations = countCombinations(k, n);
        System.out.println("Количество комбинаций: " + combinations);
    }
/*В этом коде функция countCombinations принимает два аргумента: k - количество кубиков,
и n - количество граней на каждом кубике. Внутри функции используется рекурсия для подсчета общего количества комбинаций.
Базовый случай: когда количество кубиков k равно 0, есть только одна комбинация - ни один кубик не выбран.
В остальных случаях мы перебираем все возможные значения от 1 до n на каждом кубике и рекурсивно вызываем
функцию countCombinations для k - 1 кубиков. Количество комбинаций для текущего кубика равно количеству комбинаций
для k - 1 кубиков, поэтому мы добавляем это значение в переменную sum. В конце функция возвращает сумму всех комбинаций.*/
    public static int countCombinations(int k, int n) {
        if (k == 0) { // базовый случай
            return 1;
        }
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += countCombinations(k - 1, n); // рекурсивный вызов
        }
        return sum;
    }
}
//какой сложности данный алгоритм?
/*Сложность данного алгоритма - O(N^K), где N - количество граней на кубике, K - количество кубиков.
Это связано с тем, что внутри функции countCombinations происходит цикл от 1 до N, который вызывается K раз.
Таким образом, общее количество операций будет равно N^k.
Временная сложность алгоритма будет расти экспоненциально с увеличением количества кубиков или граней,
поэтому для больших значений N и K может потребоваться оптимизация или использование другого подхода.*/

//а какая сложность данного алгоритма по использованной памяти?
/*Сложность использованной памяти данного алгоритма - O(K), где K - количество кубиков.
Это связано с тем, что внутри функции countCombinations используется только одна переменная sum,
которая хранит общее количество комбинаций. В цикле и при рекурсивных вызовах не создаются новые переменные,
поэтому сложность по использованной памяти будет равна O(K).
Таким образом, этот алгоритм использует константное количество памяти для каждой рекурсивной вызова функции
countCombinations и зависит только от количества кубиков, которые передаются в функцию.*/

//******************************************************************************************

// ниже остался вариант от ChatGPT с выводом комбинаций, их количества

//    public class DiceCombinations {
//
//        public static void main(String[] args) {
//            int k = 4; // количество кубиков
//            int n = 6; // количество граней на кубике
//            int[] combination = new int[k]; // массив для хранения комбинации
//            int count = countCombinations(k, n, combination, 0); // вызываем рекурсивную функцию
//            System.out.println("Количество комбинаций: " + count);
//        }
//
//        /**
//         * Рекурсивная функция для нахождения всех комбинаций
//         * @param k количество кубиков
//         * @param n количество граней на кубике
//         * @param combination массив для хранения комбинации
//         * @param index индекс текущего кубика
//         * @return количество комбинаций
//         */
//        public static int countCombinations(int k, int n, int[] combination, int index) {
//            if (index == k) {
//                // если все кубики выбраны, то выводим комбинацию и возвращаем 1
//                printCombination(combination);
//                return 1;
//            }
//            int count = 0;
//            for (int i = 1; i <= n; i++) {
//                combination[index] = i; // выбираем i-е число на текущем кубике
//                count += countCombinations(k, n, combination, index + 1); // рекурсивный вызов для следующего кубика
//            }
//            return count;
//        }
//
//        /**
//         * Вспомогательная функция для вывода комбинации
//         * @param combination массив с комбинацией
//         */
//        public static void printCombination(int[] combination) {
//            for (int i = 0; i < combination.length; i++) {
//                System.out.print(combination[i] + " ");
//            }
//            System.out.println();
//        }
//    }



